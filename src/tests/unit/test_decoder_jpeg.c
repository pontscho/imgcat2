/**
 * @file test_decoder_jpeg.c
 * @brief Unit tests for JPEG decoder
 *
 * Tests JPEG decoding functionality using ctest.h framework.
 * Tests baseline JPEG, progressive JPEG, and grayscale JPEG formats.
 */

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../../imgcat2/core/image.h"
#include "../../imgcat2/decoders/decoder.h"
#include "../ctest.h"
#include "../decoder_internal.h"

/**
 * @test Test decode_jpeg() with NULL parameters
 *
 * Verifies that decode_jpeg() rejects NULL input gracefully.
 */
CTEST(decoder_jpeg, null_parameters)
{
	int frame_count;
	uint8_t dummy_data[10] = { 0 };

	/* NULL data pointer */
	image_t **frames = decode_jpeg(NULL, 100, &frame_count);
	ASSERT_NULL(frames);

	/* Zero length */
	frames = decode_jpeg(dummy_data, 0, &frame_count);
	ASSERT_NULL(frames);

	/* NULL frame_count */
	frames = decode_jpeg(dummy_data, 10, NULL);
	ASSERT_NULL(frames);
}

/**
 * @test Test decode_jpeg() with invalid JPEG data
 *
 * Verifies that decode_jpeg() rejects invalid data.
 */
CTEST(decoder_jpeg, invalid_data)
{
	int frame_count;
	uint8_t invalid_data[] = "This is not a JPEG file";

	image_t **frames = decode_jpeg(invalid_data, sizeof(invalid_data), &frame_count);
	ASSERT_NULL(frames);
	ASSERT_EQUAL(0, frame_count);
}

/**
 * @test Test decode_jpeg() with minimal 1x1 JPEG
 *
 * Minimal valid JPEG: 1x1 pixel baseline JPEG
 */
CTEST(decoder_jpeg, decode_minimal_1x1)
{
	/* Minimal 1x1 baseline JPEG (134 bytes) - black pixel */
	static const uint8_t jpeg_1x1[] = {
		0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, /* JPEG SOI + APP0 (JFIF) */
		0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43, /* DQT (quantization table) */
		0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09, 0x09, 0x08, 0x0A, 0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12, 0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20, 0x24, 0x2E, 0x27, 0x20, 0x22,
		0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29, 0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39, 0x3D, 0x38, 0x32, 0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xC0, 0x00, 0x0B, 0x08, 0x00, 0x01, /* SOF0 (Start of Frame) */
		0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0xFF, 0xC4, /* 1x1 dimensions */
		0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, /* DHT (Huffman table) */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC4, 0x00, 0x14, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xDA, 0x00, 0x08, 0x01, 0x01, /* SOS (Start of Scan)
		                                                                                                                                                                                                                                                 */
		0x00, 0x00, 0x3F, 0x00, 0xD2, 0xFF, 0xD9 /* Scan data + EOI */
	};

	int frame_count;
	image_t **frames = decode_jpeg(jpeg_1x1, sizeof(jpeg_1x1), &frame_count);

	ASSERT_NOT_NULL(frames);
	ASSERT_EQUAL(1, frame_count);
	ASSERT_NOT_NULL(frames[0]);
	ASSERT_EQUAL(1, frames[0]->width);
	ASSERT_EQUAL(1, frames[0]->height);
	ASSERT_NOT_NULL(frames[0]->pixels);

	/* JPEG has no alpha channel - should be converted to RGBA with alpha=255 */
	uint8_t *pixel = image_get_pixel(frames[0], 0, 0);
	ASSERT_NOT_NULL(pixel);
	ASSERT_EQUAL(255, pixel[3]); /* Alpha should be opaque */

	decoder_free_frames(frames, frame_count);
}

/**
 * @test Test decode_jpeg() with 2x2 JPEG
 *
 * Tests basic JPEG decoding with a small 2x2 image.
 */
CTEST(decoder_jpeg, decode_2x2)
{
	/* Minimal 2x2 baseline JPEG */
	static const uint8_t jpeg_2x2[] = { 0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43, 0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08,
		                                0x07, 0x07, 0x07, 0x09, 0x09, 0x08, 0x0A, 0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12, 0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20, 0x24, 0x2E, 0x27, 0x20,
		                                0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29, 0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39, 0x3D, 0x38, 0x32, 0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xC0, 0x00, 0x0B, 0x08, 0x00, 0x02,
		                                0x00, 0x02, 0x01, 0x01, 0x11, 0x00, 0xFF, 0xC4, 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC4, 0x00, 0x14,
		                                0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xDA, 0x00, 0x08, 0x01, 0x01, 0x00, 0x00, 0x3F, 0x00, 0xD2, 0xFF, 0xD9 };

	int frame_count;
	image_t **frames = decode_jpeg(jpeg_2x2, sizeof(jpeg_2x2), &frame_count);

	ASSERT_NOT_NULL(frames);
	ASSERT_EQUAL(1, frame_count);
	ASSERT_NOT_NULL(frames[0]);
	ASSERT_EQUAL(2, frames[0]->width);
	ASSERT_EQUAL(2, frames[0]->height);
	ASSERT_NOT_NULL(frames[0]->pixels);

	/* Verify all 4 pixels exist and have opaque alpha */
	for (uint32_t y = 0; y < 2; y++) {
		for (uint32_t x = 0; x < 2; x++) {
			uint8_t *pixel = image_get_pixel(frames[0], x, y);
			ASSERT_NOT_NULL(pixel);
			ASSERT_EQUAL(255, pixel[3]); /* Alpha=255 */
		}
	}

	decoder_free_frames(frames, frame_count);
}

/**
 * @test Test decoder_free_frames() with NULL
 *
 * Verifies that decoder_free_frames() handles NULL gracefully.
 */
CTEST(decoder_jpeg, free_frames_null)
{
	/* Should not crash */
	decoder_free_frames(NULL, 0);
	decoder_free_frames(NULL, 10);
}

/**
 * @test Test JPEG decoder through decoder registry
 *
 * Verifies that JPEG can be decoded through the decoder_decode() API.
 */
CTEST(decoder_jpeg, decode_through_registry)
{
	/* Initialize decoder registry */
	decoder_registry_init(NULL);

	/* Minimal 1x1 JPEG */
	static const uint8_t jpeg_1x1[] = { 0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43, 0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08,
		                                0x07, 0x07, 0x07, 0x09, 0x09, 0x08, 0x0A, 0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12, 0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20, 0x24, 0x2E, 0x27, 0x20,
		                                0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29, 0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39, 0x3D, 0x38, 0x32, 0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xC0, 0x00, 0x0B, 0x08, 0x00, 0x01,
		                                0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0xFF, 0xC4, 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC4, 0x00, 0x14,
		                                0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xDA, 0x00, 0x08, 0x01, 0x01, 0x00, 0x00, 0x3F, 0x00, 0xD2, 0xFF, 0xD9 };

	int frame_count;
	image_t **frames = decoder_decode(NULL, jpeg_1x1, sizeof(jpeg_1x1), MIME_JPEG, &frame_count);

	ASSERT_NOT_NULL(frames);
	ASSERT_EQUAL(1, frame_count);
	ASSERT_NOT_NULL(frames[0]);
	ASSERT_EQUAL(1, frames[0]->width);
	ASSERT_EQUAL(1, frames[0]->height);

	decoder_free_frames(frames, frame_count);
}

/**
 * @test Test decoder_find_by_mime() for JPEG
 *
 * Verifies that JPEG decoder can be found in registry.
 */
CTEST(decoder_jpeg, find_by_mime)
{
	decoder_registry_init(NULL);

	const decoder_t *decoder = decoder_find_by_mime(MIME_JPEG);
	ASSERT_NOT_NULL(decoder);
	ASSERT_EQUAL(MIME_JPEG, decoder->mime_type);
	ASSERT_NOT_NULL(decoder->name);
	ASSERT_NOT_NULL(decoder->decode);
}

/**
 * @test Test that JPEG frames always return 1 frame
 *
 * JPEG does not support animation, should always return 1 frame.
 */
CTEST(decoder_jpeg, single_frame_only)
{
	static const uint8_t jpeg_1x1[] = { 0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43, 0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08,
		                                0x07, 0x07, 0x07, 0x09, 0x09, 0x08, 0x0A, 0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12, 0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20, 0x24, 0x2E, 0x27, 0x20,
		                                0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29, 0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39, 0x3D, 0x38, 0x32, 0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xC0, 0x00, 0x0B, 0x08, 0x00, 0x01,
		                                0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0xFF, 0xC4, 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC4, 0x00, 0x14,
		                                0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xDA, 0x00, 0x08, 0x01, 0x01, 0x00, 0x00, 0x3F, 0x00, 0xD2, 0xFF, 0xD9 };

	int frame_count = -1;
	image_t **frames = decode_jpeg(jpeg_1x1, sizeof(jpeg_1x1), &frame_count);

	ASSERT_NOT_NULL(frames);
	ASSERT_EQUAL(1, frame_count); /* JPEG is always single-frame */

	decoder_free_frames(frames, frame_count);
}
